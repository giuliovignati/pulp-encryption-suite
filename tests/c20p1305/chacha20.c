/*CHACHA20*/

#include "chacha20.h"
#include <stdint.h>
#include <string.h>

//Defining Macros

//32-bit left rotate operation
#define ROTL32(v, n) (((v) << (n)) | ((v) >> (32 - (n))))


//quarter round operation: this operates on four 32-bit unsigned integers, denoted a, b, c, and d.
/*  1.  a += b; d ^= a; d <<<= 16;
    2.  c += d; b ^= c; b <<<= 12;
    3.  a += b; d ^= a; d <<<= 8;
    4.  c += d; b ^= c; b <<<= 7; 
Where "+" denotes integer addition modulo 2^32, "^" denotes a bitwise Exclusive OR (XOR), and "<<< n" denotes an n-bit left rotation (towards the high bits).  
using ROTL32 is possible to shift of the number of bits specified in the 2nd argument      
*/

#define QUARTERROUND(x, a, b, c, d) \
  x[a] += x[b]; x[d] = ROTL32(x[d] ^ x[a], 16); \
  x[c] += x[d]; x[b] = ROTL32(x[b] ^ x[c], 12); \
  x[a] += x[b]; x[d] = ROTL32(x[d] ^ x[a], 8); \
  x[c] += x[d]; x[b] = ROTL32(x[b] ^ x[c], 7);



//Defining Functions

//The ChaCha block function transforms a ChaCha state by running multiple quarter rounds. It takes an output buffer, a key, a counter, and a nonce as input.
/*
uint32_t out[16] is a 512-bit (or 64-byte) output buffer.
uint32_t key[8] is a 256-bit (or 32-byte) key.
uint32_t counter is a 32-bit (or 4-byte) counter.
uint32_t nonce[3] is a 96-bit (or 12-byte) nonce.
*/
void chacha20_block(uint32_t out[16], uint32_t const key[8], uint32_t counter, uint32_t const nonce[3]) {
    if (!out || !key || !nonce) {
        printf("Null pointer error.\n");
        return;
    }

    //The key and the nonce should be read in little-endian order, but appears to be interpreted in big-endian order, so i fixed it:
    
    uint32_t le_key[8];
    for (int i = 0; i < 8; i++) {
        le_key[i] = __builtin_bswap32(key[i]);
    }
    uint32_t le_nonce[3];
    for (int i = 0; i < 3; i++) {
        le_nonce[i] = __builtin_bswap32(nonce[i]);
    }
    //

    uint32_t state[16] = {
    //The first four words (0-3) are constants: 0x61707865, 0x3320646e, 0x79622d32, 0x6b206574.
    0x61707865, 0x3320646e, 0x79622d32, 0x6b206574,
    //The next eight words (4-11) are taken from the 256-bit key by reading the bytes in little-endian order, in 4-byte chunks.
    le_key[0], le_key[1], le_key[2], le_key[3],
    le_key[4], le_key[5], le_key[6], le_key[7],
    //Word 12 is a block counter.  Since each block is 64-byte, a 32-bit word is enough for 256 gigabytes of data.
    counter,
    //Words 13-15 are a nonce, which should not be repeated for the same key. The 13th word is the first 32 bits of the input nonce taken as a little-endian integer, while the 15th word is the last 32 bits.
    le_nonce[0], le_nonce[1], le_nonce[2]
    };

    for (int i = 0; i < 16; ++i)
        out[i] = state[i];

    for (int i = 0; i < 20; i += 2) {      //ChaCha20 runs 20 rounds, alternating between "column rounds" and "diagonal rounds" each round consists of four quarter-rounds.
        QUARTERROUND(state, 0, 4, 8, 12)   //Quarter rounds 1-4 are part of a "column" round, while 5-8 are part of a "diagonal" round.
        QUARTERROUND(state, 1, 5, 9, 13)
        QUARTERROUND(state, 2, 6, 10, 14)
        QUARTERROUND(state, 3, 7, 11, 15)
        QUARTERROUND(state, 0, 5, 10, 15)
        QUARTERROUND(state, 1, 6, 11, 12)
        QUARTERROUND(state, 2, 7, 8, 13)
        QUARTERROUND(state, 3, 4, 9, 14)
    }

    for (int i = 0; i < 16; ++i)
        out[i] += state[i];
       
}


//This function encrypts a plaintext message using the ChaCha20 algorithm. It takes a ciphertext buffer, a plaintext message, the length of the message, a key, and a nonce as input.
/*
ciphertext: pointer to the array where the encrypted data will be stored.
plaintext: pointer to the array that contains the data to be encrypted.
len: length of the plaintext data.
key: encryprion key, array of 8 32bit int
nonce: number used once, used by the chacha20 for encryption, array of 3 32-bit integers.
*/

void chacha20_encrypt(uint8_t *ciphertext, uint8_t const *plaintext, uint32_t const key[8], uint32_t const nonce[3], uint32_t counter) {
    if (!ciphertext || !plaintext || !key || !nonce) {
        printf("Null pointer error.\n");
        return;
    }

    uint32_t keystream[16]; //Array keystream of 16 32-bit integers. This will hold the keystream generated by the chacha20_block function.
    chacha20_block(keystream, key, counter, nonce);

    for (size_t j = 0; j < 64; ++j)  // XOR each byte of the plaintext with the corresponding byte of the keystream
        ciphertext[j] = plaintext[j] ^ ((uint8_t *)keystream)[j];
    
}


//This function decrypts a ciphertext message using the ChaCha20 algorithm.
void chacha20_decrypt(uint8_t *plaintext, uint8_t const *ciphertext, uint32_t const key[8], uint32_t const nonce[3], uint32_t counter) {
    // ChaCha20 is a symmetric cipher, so encryption and decryption are the same operation.
    chacha20_encrypt(plaintext, ciphertext, key, nonce, counter);
}